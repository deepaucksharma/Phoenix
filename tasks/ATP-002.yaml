id: ATP-002
title: "Optimize metric filtering in Adaptive TopK processor"
state: open
priority: medium
created_at: "2025-05-20"
assigned_to: "implementer"
area: internal/processor/adaptive_topk
depends_on: ["ATP-001"]
acceptance:
  - "Memory usage during filtering is reduced by at least 50%"
  - "CPU usage during filtering is reduced"
  - "No functional regressions in filtering behavior"
  - "Performance improvements are measured and documented"
  - "Edge cases (empty metrics, high cardinality) are handled correctly"
description: |
  The current implementation of metric filtering in the Adaptive TopK processor
  creates a new metrics collection for filtered results, which could be expensive 
  for large metric sets (processor.go:176-213). This may cause high memory and CPU
  usage when processing large volumes of metrics.
  
  This task requires optimizing the filtering logic to reduce memory and CPU usage
  while maintaining the same functionality. The optimization should:
  
  1. Avoid creating a complete new metrics collection when possible
  2. Consider in-place filtering or more selective copying
  3. Optimize the lookup of top-k items for better performance
  4. Ensure thread safety is maintained
  5. Handle edge cases gracefully (empty metrics, high cardinality)
  
  Current implementation:
  ```go
  // filterMetrics filters the metrics based on the top-k set.
  func (p *processorImpl) filterMetrics(md pmetric.Metrics) error {
      p.totalIncluded = 0
      
      // Create a new metrics collection for filtered results
      filtered := pmetric.NewMetrics()
      
      // Iterate through all resource metrics
      for i := 0; i < md.ResourceMetrics().Len(); i++ {
          rm := md.ResourceMetrics().At(i)
          
          // Get resource identifier
          var resourceID string
          if val, ok := rm.Resource().Attributes().Get(p.config.ResourceField); ok {
              resourceID = val.AsString()
          } else {
              // Skip resources without the specified field
              continue
          }
          
          // Check if this resource is in the top-k set
          _, isTopK := p.topkSet[resourceID]
          
          if isTopK {
              // Include this resource in the output
              newRM := filtered.ResourceMetrics().AppendEmpty()
              rm.CopyTo(newRM)
              
              // Add topk tag to the resource
              newRM.Resource().Attributes().PutStr("aemf.topk.included", "true")
              
              p.totalIncluded++
          }
      }
      
      // Replace the original metrics with the filtered ones
      filtered.CopyTo(md)
      
      return nil
  }
  ```
  
  Potential approaches to consider:
  1. In-place marking and removal rather than creating a new collection
  2. Optimizing resource lookup in the top-k set
  3. Reusing metric structures to reduce allocations
  4. Batch processing or parallel filtering for large collections
  
  The optimized implementation should be benchmarked against the current
  implementation to verify the performance improvements.
