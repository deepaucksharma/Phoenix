extensions:
  pic_control:
    policy_file_path: /etc/sa-omf/policy.yaml
    max_patches_per_minute: 3
    patch_cooldown_seconds: 10

receivers:
  hostmetrics:
    collection_interval: 10s
    scrapers:
      # Only include process metrics to reduce cardinality
      process:
        include:
          match_type: regexp
          processes: [".*"]
        resource_attributes:
          # Include only necessary process attributes
          process.executable.name: true
          process.executable.path: false
          process.command: false
          process.command_line: false
          process.pid: true
          process.parent_pid: false
          process.owner: true
      processscraper: {}
  
  # Receiver for self-metrics collection
  prometheus/self:
    config:
      scrape_configs:
        - job_name: 'sa-omf-self'
          scrape_interval: 5s
          static_configs:
            - targets: ['localhost:8888']

processors:
  # Combined processor for resource filtering and metric transformation
  # This single processor replaces multiple separate processors for better efficiency
  metric_pipeline:
    # Resource filtering configuration (consolidates priority_tagger, adaptive_topk, others_rollup)
    resource_filter:
      enabled: true
      filter_strategy: hybrid
      priority_attribute: "aemf.process.priority"
      priority_rules:
        - match: "process.executable.name=~/java|javaw/"
          priority: high
        - match: "process.executable.name=~/nginx|httpd|apache2/"
          priority: high
        - match: "process.executable.name=~/mysql|postgres|mongod|redis-server|elasticsearch/"
          priority: critical
        - match: "process.executable.name=~/python|python3|node|dotnet|ruby/"
          priority: medium
        - match: "process.executable.name=~/otelcol|sa-omf-otelcol|collector/"
          priority: critical
        - match: "process.executable.name=~/newrelic-infra|nri-.*/"
          priority: critical
        - match: ".*"
          priority: low
      topk:
        k_value: 20
        k_min: 10
        k_max: 40
        resource_field: "process.executable.name"
        counter_field: "process.cpu.utilization"
        coverage_target: 0.95
      rollup:
        enabled: true
        priority_threshold: low
        strategy: sum
        name_prefix: "others"
    
    # Metric transformation configuration
    transformation:
      # Histogram generation
      histograms:
        enabled: true
        max_buckets: 10
        metrics:
          process.memory.usage:
            boundaries:
              - 10000000  # 10MB
              - 50000000  # 50MB  
              - 100000000 # 100MB
              - 500000000 # 500MB
              - 1000000000 # 1GB
          process.cpu.time:
            boundaries:
              - 0.1
              - 0.5
              - 1.0
              - 5.0
              - 10.0
      
      # Attribute processing
      attributes:
        actions:
          # Include only essential attributes to reduce cardinality
          - key: process.executable.name
            action: update
            value: {{ if eq .Value.String "unknown" }}default{{ else }}{{ .Value.String }}{{ end }}
          # Remove unnecessary attributes that increase cardinality
          - key: process.command_line
            action: delete
          - key: process.command
            action: delete
          - key: process.executable.path
            action: delete
          # Add New Relic compatibility attributes
          - key: collector.name
            action: insert
            value: "SA-OMF"
          - key: service.name
            action: insert
            value: {{ .Resource.Attributes.GetString "process.executable.name" "unknown" }}

exporters:
  logging:
    verbosity: detailed
  
  # Export to Prometheus for internal monitoring
  prometheusremotewrite:
    endpoint: "http://localhost:9090/api/v1/write"
    timeout: 5s

  # Export to New Relic
  otlp:
    endpoint: "https://otlp.nr-data.net:4317"
    headers:
      api-key: "${env:NEW_RELIC_API_KEY}"
    timeout: 10s
    sending_queue:
      enabled: true
      num_consumers: 4
      queue_size: 100
    retry_on_failure:
      enabled: true
      initial_interval: 5s
      max_interval: 30s
      max_elapsed_time: 300s

  pic_connector:
    # PIC connector forwards config patches to pic_control extension

service:
  # Simplified pipeline structure with one main pipeline for data processing
  # and one control pipeline for self-regulation
  pipelines:
    # Main data pipeline
    metrics:
      receivers: [hostmetrics]
      processors: [metric_pipeline, attr_filter]
      exporters: [logging, prometheusremotewrite, otlp]
    
    # Control pipeline for self-regulation
    control:
      receivers: [prometheus/self]
      processors: [adaptive_pid]
      exporters: [pic_connector]
  
  extensions: [pic_control]