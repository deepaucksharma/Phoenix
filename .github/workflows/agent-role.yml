name: Agent Role Validation

on:
  pull_request:
    branches: [ main ]

# Ensure only one agent role validation job runs at a time, and cancel in-progress runs
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

jobs:
  validate-role:
    name: Validate Agent Role
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed to get all commits

      - name: Extract role from PR body
        id: extract_role
        run: |
          # Check if we're in a pull request
          if [ -z "${{ github.event.pull_request.number }}" ]; then
            echo "This workflow should only run on pull requests"
            echo "role=skip" >> $GITHUB_OUTPUT
            echo "tasks=skip" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          PR_BODY=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}" \
            | jq -r '.body // ""')
          
          # Set default role for Dependabot PRs
          if [[ "${{ github.actor }}" == "dependabot[bot]" ]]; then
            ROLE="dependabot"
            TASKS="N/A"
          else
            ROLE=$(echo "$PR_BODY" | grep -Po '(?<=ROLE: <!-- ).*?(?= -->)' | xargs || echo "")
            TASKS=$(echo "$PR_BODY" | grep -Po '(?<=TASKS: <!-- ).*?(?= -->)' | xargs || echo "")
          fi
          
          echo "role=$ROLE" >> $GITHUB_OUTPUT
          echo "tasks=$TASKS" >> $GITHUB_OUTPUT
          
          if [ -z "$ROLE" ]; then
            echo "Error: No role declared in PR body. Add 'ROLE: <!-- role_name -->' to your PR description."
            exit 1
          elif [ "$ROLE" == "N/A" ]; then
            echo "Error: 'ROLE: <!-- N/A -->' is not permitted. A specific role must be declared."
            exit 1
          fi
          
          echo "Declared role: $ROLE"
          echo "Referenced tasks: $TASKS"
      
      - name: Check role exists
        if: steps.extract_role.outputs.role != 'skip'
        run: |
          ROLE="${{ steps.extract_role.outputs.role }}"
          if [[ "$ROLE" == "dependabot" ]]; then
            # Skip check for dependabot - create the role file if it doesn't exist
            if [ ! -f "docs/agents/$ROLE.yaml" ]; then
              echo "Creating dependabot role file"
              mkdir -p docs/agents
              cat > docs/agents/dependabot.yaml << EOF
id: dependabot
description: "Automated dependency updater"
git_permissions: push
required_checks: []
can_touch:
  - ".github/workflows/**"
  - "go.mod"
  - "go.sum"
  - "package.json"
  - "package-lock.json"
  - "yarn.lock"
blocked_files: []
must_touch: []
EOF
            fi
          elif [ ! -f "docs/agents/$ROLE.yaml" ]; then
            echo "Error: Role '$ROLE' not found in docs/agents/ directory"
            echo "Available roles: $(ls docs/agents/ | grep '.yaml' | sed 's/\.yaml//')"
            exit 1
          fi

      - name: Check file permissions
        if: steps.extract_role.outputs.role != 'skip' && steps.extract_role.outputs.role != 'dependabot'
        run: |
          ROLE="${{ steps.extract_role.outputs.role }}"
          
          # Get allowed paths from role definition
          CAN_TOUCH=$(yq -r '.can_touch[]' docs/agents/$ROLE.yaml)
          BLOCKED_FILES=$(yq -r '.blocked_files[]' docs/agents/$ROLE.yaml 2>/dev/null || echo "")
          MUST_TOUCH=$(yq -r '.must_touch[]' docs/agents/$ROLE.yaml 2>/dev/null || echo "")
          
          # Get files changed in this PR
          CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
          
          # Check blocked files
          for blocked in $BLOCKED_FILES; do
            for file in $CHANGED_FILES; do
              if [[ "$file" == $blocked ]]; then
                echo "Error: '$file' cannot be modified by role '$ROLE'"
                exit 1
              fi
            done
          done
          
          # Check if all files are allowed
          for file in $CHANGED_FILES; do
            ALLOWED=false
            for pattern in $CAN_TOUCH; do
              if [[ "$file" == $pattern ]]; then
                ALLOWED=true
                break
              fi
            done
            
            if [ "$ALLOWED" = false ]; then
              echo "Error: '$file' is not allowed to be modified by role '$ROLE'"
              exit 1
            fi
          done
          
          # Check must_touch requirements
          if [ -n "$MUST_TOUCH" ]; then
            for pattern in $MUST_TOUCH; do
              TOUCHED=false
              for file in $CHANGED_FILES; do
                if [[ "$file" == $pattern ]]; then
                  TOUCHED=true
                  break
                fi
              done
              
              if [ "$TOUCHED" = false ]; then
                echo "Error: Role '$ROLE' must modify files matching '$pattern'"
                exit 1
              fi
            done
          fi
          
          echo "All file changes comply with role '$ROLE' permissions"

      - name: Validate task references
        if: steps.extract_role.outputs.tasks != 'N/A' && steps.extract_role.outputs.role != 'dependabot' && steps.extract_role.outputs.role != 'skip'
        run: |
          TASKS="${{ steps.extract_role.outputs.tasks }}"
          if [ -z "$TASKS" ]; then
            echo "No tasks specified, skipping validation"
            exit 0
          fi
          
          IFS=',' read -ra TASK_IDS <<< "$TASKS"
          
          for task_id in "${TASK_IDS[@]}"; do
            if [ "$task_id" == "N/A" ]; then
              echo "Skipping task validation for N/A."
              continue
            fi
            task_id=$(echo $task_id | xargs)  # Trim whitespace
            
            if [ ! -f "tasks/$task_id.yaml" ]; then
              echo "Error: Task '$task_id' not found in tasks/ directory"
              exit 1
            fi
            
            TASK_STATE=$(yq -r '.state' "tasks/$task_id.yaml" 2>/dev/null || echo "")
            if [ "$TASK_STATE" = "done" ]; then
              echo "Error: Task '$task_id' is already marked as done"
              exit 1
            fi
          done
          
          echo "All referenced tasks exist and are not completed"
